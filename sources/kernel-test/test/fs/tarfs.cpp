#include <gtest/gtest.h>

#include "test/fs/fs_test.hpp"

#include <filesystem>
#include <fcntl.h>
#include <sys/mman.h>

#include "fs2/tarfs.hpp"
#include "drivers/block/driver.hpp"
#include "drivers/block/ramblk.hpp"
#include "fs2/node.hpp"
#include "fs2/vfs.hpp"

using namespace vfs2;

TEST(TarFsTest, ConvertPathName) {
    char path[detail::kTarNameSize] = "name.txt";
    VfsPath result;
    OsStatus status = detail::ConvertTarPath(path, &result);
    ASSERT_EQ(OsStatusSuccess, status);
    ASSERT_EQ(result, BuildPath("name.txt"));
}

TEST(TarFsTest, ConvertPathNestedName) {
    char path[detail::kTarNameSize] = "Users/Guest/motd.txt";
    VfsPath result;
    OsStatus status = detail::ConvertTarPath(path, &result);
    ASSERT_EQ(OsStatusSuccess, status);
    ASSERT_EQ(result, BuildPath("Users", "Guest", "motd.txt"));
}

TEST(TarFsTest, ConvertPathFolder) {
    char path[detail::kTarNameSize] = "Users/Guest/";
    VfsPath result;
    OsStatus status = detail::ConvertTarPath(path, &result);
    ASSERT_EQ(OsStatusSuccess, status);
    ASSERT_EQ(result, BuildPath("Users", "Guest"));
}

static constexpr uint8_t kTestHeader[512] = {
	0x62, 0x75, 0x69, 0x6c, 0x64, 0x2f, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x30, 0x30, 0x30, 0x30,
	0x37, 0x35, 0x35, 0x00, 0x30, 0x30, 0x30, 0x31,
	0x37, 0x35, 0x30, 0x00, 0x30, 0x30, 0x30, 0x31,
	0x37, 0x35, 0x30, 0x00, 0x30, 0x30, 0x30, 0x30,
	0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x00,
	0x31, 0x34, 0x37, 0x35, 0x32, 0x35, 0x33, 0x34,
	0x33, 0x32, 0x32, 0x00, 0x30, 0x31, 0x32, 0x33,
	0x35, 0x32, 0x00, 0x20, 0x35, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x75, 0x73, 0x74, 0x61, 0x72, 0x20, 0x20,
	0x00, 0x65, 0x6c, 0x6c, 0x69, 0x6f, 0x74, 0x68,
	0x62, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x65, 0x6c, 0x6c, 0x69, 0x6f, 0x74, 0x68,
	0x62, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
};

TEST(TarFsTest, ParseHeader) {
    sm::BTreeMap<VfsPath, TarEntry> result;
    km::MemoryBlk media((std::byte*)kTestHeader, sizeof(kTestHeader));
    km::BlockDevice block(&media);

    OsStatus status = vfs2::ParseTar(&block, {}, &result);
    ASSERT_EQ(OsStatusSuccess, status);

    ASSERT_EQ(result.size(), 1);

    auto it = result.at(BuildPath("build"));
    ASSERT_EQ(it.header.getType(), VfsNodeType::eFolder);
    ASSERT_EQ(it.header.getSize(), 0);
}

TEST(TarFsTest, MountTar) {
	vfs2::VfsRoot vfs;

	sm::SharedPtr<FileBlk> file = new FileBlk(getenv("TAR_TEST_ARCHIVE"), 512);

	{
		IVfsMount *mount = nullptr;
		OsStatus status = vfs.addMountWithParams(&TarFs::instance(), BuildPath("Mount"), &mount, file);
		ASSERT_EQ(OsStatusSuccess, status);
		ASSERT_NE(mount, nullptr);
	}

	{
		std::unique_ptr<IVfsNodeHandle> motd;
		OsStatus status = vfs.open(BuildPath("Mount", "motd.txt"), std::out_ptr(motd));
		ASSERT_EQ(OsStatusSuccess, status);
		ASSERT_NE(motd, nullptr);

		char data[512];
		ReadRequest request {
			.begin = std::begin(data),
			.end = std::end(data),
			.offset = 0,
		};
		ReadResult result{};
		status = motd->read(request, &result);
		ASSERT_EQ(OsStatusSuccess, status);
		ASSERT_GT(result.read, 0);

		char expected[] = "Tar parsing test file\n";
		ASSERT_EQ(memcmp(data, expected, sizeof(expected)), 0);
	}

	{
		std::unique_ptr<IVfsNodeHandle> hello;
		OsStatus status = vfs.open(BuildPath("Mount", "subdir", "nested", "hello.txt"), std::out_ptr(hello));
		ASSERT_EQ(OsStatusSuccess, status);
		ASSERT_NE(hello, nullptr);

		char data[512];
		ReadRequest request {
			.begin = std::begin(data),
			.end = std::end(data),
			.offset = 0,
		};
		ReadResult result{};
		status = hello->read(request, &result);
		ASSERT_EQ(OsStatusSuccess, status);
		ASSERT_GT(result.read, 0);

		char expected[] = "I am in a folder!\n";
		ASSERT_EQ(memcmp(data, expected, sizeof(expected)), 0);
	}
}

TEST(TarFsTest, ReadLargeFile) {
	vfs2::VfsRoot vfs;

	sm::SharedPtr<FileBlk> file = new FileBlk(getenv("TAR_TEST_ARCHIVE"), 512);

	{
		IVfsMount *mount = nullptr;
		OsStatus status = vfs.addMountWithParams(&TarFs::instance(), BuildPath("Mount"), &mount, file);
		ASSERT_EQ(OsStatusSuccess, status);
		ASSERT_NE(mount, nullptr);
	}

	{
		std::unique_ptr<IVfsNodeHandle> hello;
		OsStatus status = vfs.open(BuildPath("Mount", "subdir", "nested", "services.log"), std::out_ptr(hello));
		ASSERT_EQ(OsStatusSuccess, status);
		ASSERT_NE(hello, nullptr);

		char data[1024];
		ReadRequest request {
			.begin = std::begin(data),
			.end = data + 833,
			.offset = 23,
		};
		ReadResult result{};
		status = hello->read(request, &result);
		ASSERT_EQ(OsStatusSuccess, status);
		ASSERT_EQ(result.read, 833);
	}
}
