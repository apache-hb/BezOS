#include <gtest/gtest.h>

#include <filesystem>
#include <fcntl.h>
#include <sys/mman.h>

#include "fs2/tarfs.hpp"
#include "drivers/block/driver.hpp"
#include "drivers/block/ramblk.hpp"
#include "fs2/node.hpp"
#include "fs2/vfs.hpp"

using namespace vfs2;

TEST(TarFsTest, ConvertPathName) {
    char path[detail::kTarNameSize] = "name.txt";
    VfsPath result;
    OsStatus status = detail::ConvertTarPath(path, &result);
    ASSERT_EQ(OsStatusSuccess, status);
    ASSERT_EQ(result, BuildPath("name.txt"));
}

TEST(TarFsTest, ConvertPathNestedName) {
    char path[detail::kTarNameSize] = "Users/Guest/motd.txt";
    VfsPath result;
    OsStatus status = detail::ConvertTarPath(path, &result);
    ASSERT_EQ(OsStatusSuccess, status);
    ASSERT_EQ(result, BuildPath("Users", "Guest", "motd.txt"));
}

TEST(TarFsTest, ConvertPathFolder) {
    char path[detail::kTarNameSize] = "Users/Guest/";
    VfsPath result;
    OsStatus status = detail::ConvertTarPath(path, &result);
    ASSERT_EQ(OsStatusSuccess, status);
    ASSERT_EQ(result, BuildPath("Users", "Guest"));
}

static constexpr uint8_t kTestHeader[512] = {
	0x62, 0x75, 0x69, 0x6c, 0x64, 0x2f, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x30, 0x30, 0x30, 0x30,
	0x37, 0x35, 0x35, 0x00, 0x30, 0x30, 0x30, 0x31,
	0x37, 0x35, 0x30, 0x00, 0x30, 0x30, 0x30, 0x31,
	0x37, 0x35, 0x30, 0x00, 0x30, 0x30, 0x30, 0x30,
	0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x00,
	0x31, 0x34, 0x37, 0x35, 0x32, 0x35, 0x33, 0x34,
	0x33, 0x32, 0x32, 0x00, 0x30, 0x31, 0x32, 0x33,
	0x35, 0x32, 0x00, 0x20, 0x35, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x75, 0x73, 0x74, 0x61, 0x72, 0x20, 0x20,
	0x00, 0x65, 0x6c, 0x6c, 0x69, 0x6f, 0x74, 0x68,
	0x62, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x65, 0x6c, 0x6c, 0x69, 0x6f, 0x74, 0x68,
	0x62, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
};

TEST(TarFsTest, ParseHeader) {
    BTreeMap<VfsPath, TarEntry> result;
    km::MemoryBlk media((std::byte*)kTestHeader, sizeof(kTestHeader));
    km::BlockDevice block(&media);

    OsStatus status = vfs2::ParseTar(&block, {}, &result);
    ASSERT_EQ(OsStatusSuccess, status);

    ASSERT_EQ(result.size(), 1);

    auto it = result.at(BuildPath("build"));
    ASSERT_EQ(it.header.getType(), VfsNodeType::eFolder);
    ASSERT_EQ(it.header.getSize(), 0);
}

class FileBlk final : public km::IBlockDriver {
	uint32_t mBlockSize;

	int mFileHandle = 0;
	void *mMemoryMap = nullptr;
	size_t mMemorySize = 0;

	void cleanup() {
		if (mMemoryMap) {
			munmap(mMemoryMap, mMemorySize);
			mMemoryMap = nullptr;
		}

		if (mFileHandle >= 0) {
			close(mFileHandle);
			mFileHandle = -1;
		}
	}

	km::BlockDeviceStatus readImpl(uint64_t block, void *buffer, size_t count) override {
		memcpy(buffer, (uint8_t*)mMemoryMap + (block * mBlockSize), count * mBlockSize);
		return km::BlockDeviceStatus::eOk;
	}

	km::BlockDeviceStatus writeImpl(uint64_t, const void *, size_t) override {
		return km::BlockDeviceStatus::eReadOnly;
	}

public:
	FileBlk(const std::filesystem::path& path, uint32_t blockSize)
		: mBlockSize(blockSize)
	{
		mFileHandle = open(path.string().c_str(), O_RDONLY);
		if (mFileHandle < 0) {
			std::cerr << "Failed to open file: " << path << " = " << errno << std::endl;
			throw std::runtime_error("Failed to open file");
		}

		struct stat statbuf;
		if (fstat(mFileHandle, &statbuf) < 0) {
			std::cerr << "Failed to stat file: " << path << " = " << errno << std::endl;
			cleanup();
			throw std::runtime_error("Failed to stat file");
		}

		mMemorySize = statbuf.st_size;
		mMemoryMap = mmap(nullptr, mMemorySize, PROT_READ, MAP_PRIVATE, mFileHandle, 0);
		if (mMemoryMap == MAP_FAILED) {
			std::cerr << "Failed to mmap file: " << path << " = " << errno << std::endl;
			cleanup();
			throw std::runtime_error("Failed to mmap file");
		}
	}

	~FileBlk() {
		cleanup();
	}

	km::BlockDeviceCapability capability() const override {
		return km::BlockDeviceCapability {
			.protection = km::Protection::eRead,
			.blockSize = mBlockSize,
			.blockCount = mMemorySize / mBlockSize,
		};
	}
};

TEST(TarFsTest, MountTar) {
	vfs2::VfsRoot vfs;

	sm::SharedPtr<FileBlk> file = new FileBlk(getenv("TAR_TEST_ARCHIVE"), 512);

	{
		IVfsMount *mount = nullptr;
		OsStatus status = vfs.addMountWithParams(&TarFs::instance(), BuildPath("Mount"), &mount, file);
		ASSERT_EQ(OsStatusSuccess, status);
		ASSERT_NE(mount, nullptr);
	}

	{
		std::unique_ptr<IVfsNodeHandle> motd;
		OsStatus status = vfs.open(BuildPath("Mount", "motd.txt"), std::out_ptr(motd));
		ASSERT_EQ(OsStatusSuccess, status);
		ASSERT_NE(motd, nullptr);

		char data[512];
		ReadRequest request {
			.begin = std::begin(data),
			.end = std::end(data),
			.offset = 0,
		};
		ReadResult result{};
		status = motd->read(request, &result);
		ASSERT_EQ(OsStatusSuccess, status);
		ASSERT_GT(result.read, 0);

		char expected[] = "Tar parsing test file\n";
		ASSERT_EQ(memcmp(data, expected, sizeof(expected)), 0);
	}

	{
		std::unique_ptr<IVfsNodeHandle> hello;
		OsStatus status = vfs.open(BuildPath("Mount", "subdir", "nested", "hello.txt"), std::out_ptr(hello));
		ASSERT_EQ(OsStatusSuccess, status);
		ASSERT_NE(hello, nullptr);

		char data[512];
		ReadRequest request {
			.begin = std::begin(data),
			.end = std::end(data),
			.offset = 0,
		};
		ReadResult result{};
		status = hello->read(request, &result);
		ASSERT_EQ(OsStatusSuccess, status);
		ASSERT_GT(result.read, 0);

		char expected[] = "I am in a folder!\n";
		ASSERT_EQ(memcmp(data, expected, sizeof(expected)), 0);
	}
}
